# rules.mk
#
# Правила компиляции, цели
#
# GOALS:
# clean	- clean working dirs
# fhex	- Intel .hex for flash
# ehex	- Intel .hex for eeprom
# fsrec	- Motorola .srec for flash
# esrec	- Motorola .srec for eeprom
# fbin	- .bin for flash
# ebin	- .bin for eeprom
# lst	- listing
# elf   - .elf file
# tag   - tags, cscope.out
#

all : clean flash eeprom lst

eeprom: ehex ebin esrec
flash: fhex fbin fsrec
hex: fhex ehex
bin: fbin ebin
srec: fsrec esrec

.PHONY: clean fhex ehex fsrec esrec fbin ebin
.PHONY: lst flash eeprom hex srec bin all tag


CMP             ?= cmp
CP              ?= cp
MKDIR           ?= mkdir -p
MV              ?= mv
RM              ?= rm
SED             ?= sed
HEAD            ?= head
HOST_CC         ?= gcc

CC              := avr-gcc -mmcu=$(MCU_TARGET) -I.
OBJCOPY         := avr-objcopy
OBJDUMP         := avr-objdump
CTAGS           ?= ctags
CSCOPE          ?= cscope


LD_FLAGS        := $(LDFLAGS) -Wl,-Map,$(OBJDIR)/$(PRG).map

C_FLAGS         := $(CFLAGS) $(REGS) $(OPTIMIZE)
C_OBJS          := $(C_SRC:%.c=$(OBJDIR)/%.o)
C_DEPS          := $(C_OBJS:%=%.d)

CPP_FLAGS       := $(CPPFLAGS) $(REGS) $(OPTIMIZE)
CPP_OBJS        := $(CPP_SRC:%.cpp=$(OBJDIR)/%.o)
CPP_DEPS        := $(CPP_OBJS:%=%.d)

AS_FLAGS        := $(ASFLAGS)
AS_OBJS         := $(AS_SRC:%.S=$(OBJDIR)/%.o)
AS_DEPS         := $(AS_OBJS:%=%.d)

OBJS            := $(C_OBJS) $(CPP_OBJS) $(AS_OBJS)
DEPS            := $(C_DEPS) $(CPP_DEPS) $(AS_DEPS)


.SECONDARY : $(OBJS) $(DEPS)


fhex:  $(PRG).hex
fbin:  $(PRG).bin
fsrec: $(PRG).srec
lst:  $(PRG).lst
ehex:  $(PRG)_eeprom.hex
ebin:  $(PRG)_eeprom.bin
esrec: $(PRG)_eeprom.srec
elf:   $(OBJDIR)/$(PRG).elf


.SECONDARY : $(OBJDIR)/$(PRG).elf



ifdef MAKE_HEAP_START_H
define make-heap-start-h
 @echo "/* DO NOT EDIT THIS FILE! */" > new-heap-start.h
 @echo "/* This file is auto generated */" >> new-heap-start.h
 @$(SED) -e "/__heap_start/!d"   \
    -r -e "s/([[:space:]]*0x008)([^[:space:]]+).*/#define HEAP_START 0x\2/" \
    $(OBJDIR)/$(PRG).map >> new-heap-start.h
 @if $(CMP) -s new-heap-start.h heap-start.h ;      \
    then $(RM) new-heap-start.h ;    \
    else $(MV) -f new-heap-start.h heap-start.h ;   \
    $(MAKE) $(OBJDIR)/$(PRG).elf ;   \
 fi
endef
else
make-heap-start-h =
endif

$(OBJDIR)/$(PRG).elf : $(OBJS)
	$(CC) $(C_FLAGS) $(LD_FLAGS) $^ -o $@
	$(call make-heap-start-h)
	@echo


%.lst: $(OBJDIR)/%.elf
	-@$(RM) $@ 2> /dev/nul
	$(OBJDUMP) -h -s -S $< > $@



# make_eeprom  format,goals
define make_eeprom
 -@$(RM) $@ 2> /dev/nul
 $(if $(or $(filter eeprom,$(2)), \
           $(filter ehex,$(2)),   \
           $(filter ebin,$(2)),   \
           $(filter esrec,$(2))), \
   $(OBJCOPY) -j .eeprom --change-section-lma .eeprom=1 -O $(1) $< $@, \
   -$(OBJCOPY) -j .eeprom --change-section-lma .eeprom=1 -O $(1) $< $@ \
 )
endef

%_eeprom.hex: $(OBJDIR)/%.elf
	$(call make_eeprom,ihex,$(MAKECMDGOALS))

%_eeprom.srec: $(OBJDIR)/%.elf
	$(call make_eeprom,srec,$(MAKECMDGOALS))

%_eeprom.bin: $(OBJDIR)/%.elf
	$(call make_eeprom,binary,$(MAKECMDGOALS))



#####################################
# helper for make crc of .hex file
#

ifdef MAKE_CRC_OF_FILE

define GETCRC_SOURCE_HEX
/* getcrc-hex.c */

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

unsigned short int CRC = 0;
unsigned long int FINISH = 0;

unsigned short int ByteCRC( unsigned short int CRC, unsigned char c )
{
	int i;
	CRC ^= c;
	for ( i = 0; i < 8; ++i ) if ( CRC & 1 ) { CRC >>= 1; CRC ^= 0xA001; }
		else CRC >>= 1;
	return CRC;
} // ByteCRC

unsigned char ReadNibble( void )
{
	int ch = getchar();
	if ( EOF == ch ) return 0;
	ch = toupper( ch );
	if ( ch >= 'A' ) ch = 10 + ch - 'A';
	else ch = ch - '0';
	return ch;
} // ReadNibble

#define ReadByte() ((ReadNibble() << 4) + ReadNibble())

int ReadLine( void )
{
	int bytes;
	int addr;
	int ch = getchar();
	if ( EOF == ch ) return 0;
	if ( ':' != ch ) exit(1);

	bytes = ReadByte();
	addr = ReadByte() * 256u + ReadByte();

	if ( !ReadByte() )
	{
		if ( !FINISH ) FINISH = addr;
		else if ( FINISH != addr ) exit(1);

		for ( ; bytes; -- bytes )
		{
			CRC = ByteCRC( CRC, ReadByte() );
			++FINISH;
		}
	}
	while ( (EOF != ch) && ('\n' != ch) ) ch = getchar();
	return 1;
} // ReadLine

int main( void )
{
	while ( ReadLine() ) (void)0;
	int sum = (0-(2 + (FINISH >> 8) + FINISH + CRC + (CRC >> 8))) & 0xff;
	printf( ":02%04X00%02X%02X%02X\n", (int)FINISH, (int)(CRC & 0xFF),
			(int)((CRC >> 8) & 0xFF), (int)(sum) );
	return 0;
} // main

/* End of file  getcrc-hex.c */
endef

getcrc_hex := getcrc-hex.exe

.INTERMEDIATE : $(getcrc_hex) getcrc-hex.c

$(getcrc_hex) : getcrc-hex.c
	$(HOST_CC) getcrc-hex.c -o $@

export GETCRC_SOURCE_HEX
getcrc-hex.c :
	echo "$${GETCRC_SOURCE_HEX}" > getcrc-hex.c


define make-crc-of-hex
 $(HEAD) --lines=-1 $@ > n-$@
 ./$(getcrc_hex) < $@ >> n-$@
 echo :00000001FF >> n-$@
 $(MV) n-$@ $@
endef


define GETCRC_SOURCE_BIN
/* getcrc-bin.c */

#include <stdio.h>

unsigned short int CRC = 0;

unsigned short int ByteCRC( unsigned short int CRC, unsigned char c )
{
	int i;
	CRC ^= c;
	for ( i = 0; i < 8; ++i ) if ( CRC & 1 ) { CRC >>= 1; CRC ^= 0xA001; }
		else CRC >>= 1;
	return CRC;
} // ByteCRC

int main( void )
{
	int ch;
	while ( (ch = getchar()) != EOF ) CRC = ByteCRC( CRC, ch );
	printf( "%c%c", (char)(CRC & 0xFF), (char)((CRC >> 8) & 0xFF) );
	return 0;
} // main

/* End of file  getcrc-bin.c */
endef

getcrc_bin := getcrc-bin.exe

.INTERMEDIATE : $(getcrc_bin) getcrc-bin.c

$(getcrc_bin) : getcrc-bin.c
	$(HOST_CC) getcrc-bin.c -o $@

export GETCRC_SOURCE_BIN
getcrc-bin.c :
	echo "$${GETCRC_SOURCE_BIN}" > getcrc-bin.c


define make-crc-of-bin
 $(CP) $@ n-$@
 ./$(getcrc_bin) < $@ >> n-$@
 $(MV) n-$@ $@
endef


else
make-crc-of-hex :=
getcrc_hex :=
make-crc-of-bin :=
getcrc_bin :=
endif

#
# helper for make crc of .hex file
#####################################


%.hex: $(OBJDIR)/%.elf $(getcrc_hex)
	-@$(RM) $@ 2> /dev/nul
	$(OBJCOPY) -j .text -j .data -O ihex $< $@
	$(call make-crc-of-hex)

%.srec: $(OBJDIR)/%.elf
	-@$(RM) $@ 2> /dev/nul
	$(OBJCOPY) -j .text -j .data -O srec $< $@

%.bin: $(OBJDIR)/%.elf $(getcrc_bin)
	-@$(RM) $@ 2> /dev/nul
	$(OBJCOPY) -j .text -j .data -O binary $< $@
	$(call make-crc-of-bin)



# make_obj  lang
define make_obj
 $(CC) -MMD -MF $@.p.d -c $($(strip $(1))_FLAGS)   \
       $($(strip $(1))_FLAGS_$<) $< -o $@
 @$(SED) -e 's/.*:/SRC_FILES +=/g' < $@.p.d > $@.d
 @$(SED) -e "1s/^.*:/\n$(subst /,\/,$@) $(subst /,\/,$@).d : \\\\\n/"        \
         -e "\$$s/$$/ \\\\\n $(subst /,\/,$($(strip $(1))_MK_FILES_$<))\n/"  \
         < $@.p.d >> $@.d
 @$(SED) -e 's/^[^:]*: *//' -e 's/^[ \t]*//'   \
         -e 's/ \\$$//' -e 's/$$/ :/' < $@.p.d >> $@.d
 -@$(RM) -f $@.p.d
 @echo
endef


$(C_OBJS) : $(OBJDIR)/%.o : %.c
	$(call make_obj,C)

$(CPP_OBJS) : $(OBJDIR)/%.o : %.cpp
	$(call make_obj,CPP)

$(AS_OBJS) : $(OBJDIR)/%.o : %.S
	$(call make_obj,AS)



clean:
	-@$(RM) -rf $(OBJDIR)/$(PRG).elf
	-@$(RM) -rf $(PRG).lst $(OBJDIR)/$(PRG).map
	-@$(RM) -rf $(PRG).hex $(PRG).bin $(PRG).srec
	-@$(RM) -rf $(PRG)_eeprom.hex $(PRG)_eeprom.bin $(PRG)_eeprom.srec
	-@$(RM) -rf $(MK_DIRS:%=%/*.o) $(MK_DIRS:%=%/*.o.d)
	-@$(RM) -f tags cscope.out


# include dep. files
ifneq "$(MAKECMDGOALS)" "clean"
-include $(DEPS)
endif



ifeq "tag" "$(findstring tag,$(subst tags,tag,$(MAKECMDGOALS)))"


# make_dep  lang
define make_dep
 $(CC) -MM $($(strip $(1))_FLAGS) $($(strip $(1))_FLAGS_$<) $< -o $@.p.d 
 @$(SED) -e 's/.*:/SRC_FILES +=/g' < $@.p.d > $@
 @$(SED) -e "1s/^.*:/\n$(subst /,\/,$(@:%.d=%)) $(subst /,\/,$@) : \\\\\n/"  \
         -e "\$$s/$$/ \\\\\n $(subst /,\/,$($(strip $(1))_MK_FILES_$<))\n/"  \
         < $@.p.d >> $@
 @$(SED) -e 's/^[^:]*: *//' -e 's/^[ \t]*//'   \
         -e 's/ \\$$//' -e 's/$$/ :/' < $@.p.d >> $@
 -@$(RM) -f $@.p.d
 @echo
endef


$(C_DEPS) : $(OBJDIR)/%.o.d : %.c
	$(call make_dep,C)

$(CPP_DEPS) : $(OBJDIR)/%.o.d : %.cpp
	$(call make_dep,CPP)

$(AS_DEPS) : $(OBJDIR)/%.o.d : %.S
	$(call make_dep,AS)


tag: tags
tags: $(SRC_FILES)
	if [ -e tags ] ; then $(CTAGS) -u $? ; else $(CTAGS) $^ ; fi
	$(CSCOPE) -U -b $^


endif



# Create directories
$(shell $(MKDIR) $(MK_DIRS) 2>/dev/null)


#
# End of file  rules.mk
