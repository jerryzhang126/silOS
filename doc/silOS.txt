(c) 2009 Потрепалов И.С.

Предварительные наброски...


1. Введение

При написании программ для управления реальными физическими объектами
программист сталкивается с асинхронной природой событий реального мира [1].
Эта асинхронность требует от программ таких же асинхронных реакций.
Кроме того, реакции на внешние события должны генерироваться в течении
ограниченного времени.  Два этих требования естественным образом
удовлетворяются реализацией программ в виде асинхронно взаимодействующих
потоков (задач) имеющих разные приоритеты (выполняющихся с разной скоростью).
Существует множество операционных систем и библиотек функций облегчающих
написание программ в таком стиле (с использованием потоков, имеющих
различный приоритет).  В данной работе описывается операционная система
silOS (Short Interrupt Latency OS), реализованная в виде библиотеки функций,
которые эмулируют многопоточность программы на одном процессоре.

Операционная система silOS предназначена для использования в
микроконтроллерах с очень ограниченным количеством ресурсов.  Диспетчер
потоков и средства синхронизации оптимизированы для случаев, когда
количество потоков измеряется единицами (в пределах 20-30), и при количестве
потоков более полусотни становятся не так эффективны (для таких случаев
существуют более эффективные реализации).



2. Определения

Поток -- это часть программы, выполняющаяся одновременно с другими потоками
этой же или любой другой программы на одном компьютере.  В многопроцессорных
системах потоки действительно выполняются одновременно.  В однопроцессорной
системе одновременность выполнения потоков эмулируется независимостью
(от потоков) моментов переключения процесса исполнения команд из разных
потоков (такие переключения возникают, например, вследствии обработки
прерываний).  Обычно, каждый поток выполняет какую-либо функцию, которая
не предполагает своего завершения.  Такая функция называется функцией потока
(при этом, разные потоки могут выполнять одну и ту же функцию).  В silOS
функция потока либо не должна завершаться, либо должна завершаться переходом
в функцию Stop.  Функцию потока нельзя вызывать как обычную функцию.
(В некоторых операционных системах вместо слова "поток" используют
слово "процесс", что не совсем верно, т.к. процессы предполагают
более строгую изоляцию друг от друга.)

Состояния потоков.  Поток может находится в одном из следующих состояний:
 - выполнения (когда процессор выполняет функцию данного потока);
 - готовности к выполнению;
 - ожидания (поток ожидает событие, активизацию, освобождение ресурса и т.п.).

Поток считается активным, если он выполняется или готов к выполнению. Поток
считается заблокированным, если он находится в состоянии ожидания.

В ондопроцессорной системе процессор в каждый момент времени может либо
выполнять процедуру обработки прерывания, либо выполнять функцию одного
из потоков, либо выполнять процедуру изменения состояния потоков.

Приоритет потока, номер потока.  При изменении состояния любого потока
выполняться начинает (или продолжает) поток с наибольшим приоритетом (как
обычно, это поток с наименьшим номером).  Прочие потоки оказываются либо в
состоянии ожидания, либо в состоянии готовности к выполнению.  Номера
потоков начинаются с единицы.

Контекст потока.  С каждым потоком ассоциируется стек, значение счетчика
команд и состояние прочих регистров процессора.  Все эти данные составляют
контекст потока, и у потоков, которые в данный момент не выполняются,
сохраняются в специальной структуре: блоке состояния потока (Thread State
Block, TSB).

У операционной системы silOS количество блоков, а значит и потоков,
задается на этапе компиляции программы (макросом NumThreads) и во время
работы не изменяется.  Блоки размещаются в статическом массиве с
именем OS_TSBs.  При этом номер потока однозначно соотносится с индексом
блока состояния в массиве; и чем меньше этот номер, тем выше приоритет потока.

Диспетчер потоков -- это специальная функция, которая в определённые моменты
времени (после обработки прерываний, активизации какого-либо потока и т.п.)
выбирает наиболее приоритетный из активных потоков и переходит к его
выполнению.  Именно диспетчер потоков переводит очередной поток в состояние
выполенения.  При отсутствии потоков готовых к выполнению, диспетчер потоков
ожидает их появления и выполняет в это время функцию IdleFunc, если она
определена (если такой функции нет, то диспетчер потоков в цикле ожидает
появления активного потока).

Разделяемый ресурс -- это ресурс с которым одновременно могут работать
(читать или изменять его) несколько потоков.  Асинхронность (по отношению
к потокам) моментов переключения исполнения разных потоков несет
в себе опасность несогласованного использования разделяемых ресурсов и их
ошибочного изменения.  Даже переменная из одного байта при одновременном
изменении её значения разными потоками может принять неправильное
(непредусмотренное алгоритмом) значение.  Для исключения несогласованности
в использовании разделяемых ресурсов предназначены средства синхронизации
потоков: мьютексы, сигналы, события, семафоры и т.п.

Мьютекс (или битовый семафор, как его называют в [2]) -- средство
синхронизации потоков предотвращающее одновременную работу с разделяемым
ресурсом нескольких потоков.  С каждым разделяемым ресурсом, работу с
которым нужно синхронизировать, ассоциируется свой мьютекс.  Перед началом
работы с ресурсом поток должен захватить соответствующий мьютекс, а по
окончании работы -- освободить.  При этом, если в момент захвата мьютекса
он уже занят (принадлежит какому-либо другому потоку), поток, желающий его
захватить, переводится в состояние ожидания освобождения мьютекса.
В некоторых операционных системах возможна ситуация, называемая инверсией
приоритетов: более приоритетный поток ожидает освобождения мьютекса,
захваченного менее приоритетным потоком, а в это время работает поток с
промежуточным приоритетом (поток 3 захватывает некоторый мьютекс, начинает
работать поток 2, затем поток 1; поток 1 пытается захватить тот же мьютекс
и переводится в состояние ожидания освобождения мьютекса; в это время
работает поток 2; таким образом поток 1 ожидает завершения работы потока 2
и освобождения мьютекса).  В silOS инверсии приоритетов нет, вместо этого
приоритет ожидающего потока, если он больше, переходит к потоку, владеющему
мьютексом.

Семафор -- средство синхронизации потоков, ограничивающее количество
одновременно работающих потоков связаных с данным семафором.  Обычно семафор
реализуется счетчиком, соответствующим "количеству открытых путей
за семафором"; при этом закрытому состоянию семафора соответствует нулевое
значение в счетчике, а открытому -- ненулевое.  Поток, который пытается
закрыть уже закрытый семафор переводится в состояние ожидания открытия
семафора.  При открытии семафора либо активизивуется наиболее приоритетный
из тех потоков, которые ожидают открытия данного семафора (при этом
семафор остается в закрытом состоянии), либо увеличивается счетчик
семафора (если нет потоков, ожидающих открытия данного семафора; при этом
семафор открывается или остается открытым).

Сигнал -- средство синхронизации потоков, предназначенное для сообщения
потокам о выполнении некоторого условия (или состояния).  Сигнал может
быть либо установленным, либо сброшенным.  При установке сигнала все потоки,
которые ожидали данный сигнал, переводятся в состояние готовности к
выполнению.  После установки сигнала он остается активным в течении
некоторого времени, до его явного сброса.  Поток переводится в состояние
ожидания сигнала только в том случае, если в момент обращения к сигналу
последний будет сброшен.

Событие -- средство синхронизации потоков, позволяющее информировать потоки
о наступлении некоторого события.  По определению, событие не имеет
длительности.  Поэтому при наступлении события активизируются только те
потоки, которые находились в состоянии ожидания данного события на момент
его наступления.  При обращении к событию поток обязательно переводится
в состояние ожидания наступления данного события.

Системный таймер.  Неотъемлимой частью любой операционной системы реального
времени является средство контроля и распределения времени, некоторый
таймер.  В silOS данную задачу выполняет системный таймер.  Системный
таймер реализован в виде макроса OS_TICK, который должен выполняться с
определённой периодичностью.  Периодичность его выполнения задаёт
прикладной программист при написании программы.  Интервалы времени в
функциях silOS задаются как количество выполнений данного макроса.
Для облегчения написания программ предназначены макросы конвертации
миллисекунд в тики системного таймера (msToTicks) и обратно (TicksToMS).



3. Обзор существующих систем

Существует большое количество операционных систем.  Только некоторые из них
можно использовать при программировании микроконтроллеров с малым объёмом
памяти (до 4-х килобайтов).  Здесь приводится обзорное сравнение известных
систем с silOS.

Так как silOS является системой с вытесняющей многозадачностью, то
нет смысла сравнивать silOS с системами кооперативной многозадачности
(такими как, например, Salvo RTOS, freeRTOS и т.п.).



3.1. uCOS-II

Прекрасная операционная система.  Имеет множество настроек.  Но весьма
требовательна к памяти.  Не подходит для микроконтроллеров с 512-1024 байтами
оперативной памяти.



3.3. FreeRTOS



3.2. scmRTOS

Одна из лучших отечественных разработок.  Система silOS во многом похожа
на scmRTOS, но имеет ряд существенных отличий:
 - scmRTOS ориентирована на язык C++; silOS одинаково легко используется
в проектах на ассемблере, C и C++;
 - критические секции в scmRTOS организуются путём запрещения прерываний;
в silOS приложено максимум усилий для сокращения времени, когда прерывания
запрещены, и критические секции потоков организуются блокировкой
диспетчера потоков;
 - идентификаторы средств синхронизации процессов в scmRTOS создаются
средствами компилятора, что является несомненным преимуществом по
сравнению с silOS, но в silOS средства синхронизации потоков занимают
меньше места в оперативной памяти;
 - средства синхронизации в scmRTOS нельзя передавать из функции в функцию;
в silOS это делать можно;
 - в scmRTOS количество процессов ограничено шестнадцатью (включая
один системный); в silOS количество потоков ограничено 255 и доступной
памятью.  В silOS имеется механизм аналогичный системному процессу
IdleProcess системы scmRTOS, но это не отдельный поток, а специальным
образом оформленная подпрограмма;
 - системный таймер в scmRTOS является частью системы; в silOS имеются
только заготовки для организации системного таймера, окончательный
выбор места и способа реализации системного таймера остаётся за
прикладным программистом;
 - в scmRTOS передачу управления в диспетчер процессов настоятельно
рекомендуется выполняется с помощью прерывания (для чего требуется выделять
весьма специфический ресурс микроконтроллера); в silOS управление в диспетчер
потоков передаётся при завершении обработки любого прерывания (при
соответствующем оформлении функций обработки прерываний).

Наиболее существенное отличие silOS от всех систем -- сокращенное время
задержки обработки прерываний по вине операционной системы: silOS
увеличивает это время менее, чем на 50 тактов.  И именно это являлось
целью при разработке silOS.



4. Особенности silOS

Очень маленькая задержка обработки прерываний по вине ОС
Оптимизация для микроконтроллеров с малым количеством ресурсов
Очень быстрый макрос активизации потока (от 4 до 9 команд)
Быстрая реакция на прерывания
Возможность обработки вложенных прерываний
Быстрое переключение контекста
Малый размер данных ОС
Статическое размещение структур ОС
Статическое назначение приоритетов потокам
Функции ОС разрешают прерывания только при блокировании	текущего потока



4.1. Тип данных RegType_t

Тип данных RegType_t определяется таким образом, чтобы значения данного типа
могли размещаться в любом одном регистре процессора.  Большинство типов
операционной системы являются подтипами указанного типа.



4.2. Вовзращаемые функциями значения

Большинство функций операционной системы возвращают значение, которое
показывает результат работы функции.  Значения, возвращаемые различными
функциями, унифицированы следующим образом:

0 -- поток активизирован по таймауту;
1 -- успешный захват ресурса;
3 -- повторный захват ресурса;
240 (0xF0) -- поток принудительно активизирован функцией Thread_Activate.


4.3. Передача параметров

Передача параметров в функции операционной системы silOS осуществляется
в соответствии с соглашениями установленными компилятором avr-gcc:
первый параметр передается в регистрах r25:r24, второй параметр --
в регистрах r23:r22, третий -- r21:r20, возвращаемое значение размещается
в регистре r24 или в регистрах r25:r24 (если возвращается значение
типа int).



5. Диспетчер потоков и обработка прерываний

Диспетчер потоков выполняет поиск и последующий запуск наиболее
приоритетного из активных потоков.  Диспетчер потоков вызывается после
изменения множества активных потоков.  Если изменение множества активных
потоков происходит в прерывании, то диспетчер потоков вызывается при
выходе из самого первого, внешнего прерывания (при работе с вложенными
прерываниями).

Для управление диспетчером потоков используются функции:
Scheduler_IsLocked - определение состояния диспетчера потоков;
Scheduler_Lock - блокировка работы диспетчера потоков;
Scheduler_Unlock - освобождение диспетчера потоков от блокировки
(разблокирование диспетчера потоков).

Состояние диспетчера потоков реализовано как переменная-счетчик.  Функции
Scheduler_Lock и Scheduler_Unlock соответственно увеличивают и уменьшают
(до нуля) значение этого счетчика.  Если в переменной не ноль, то диспетчер
потоков заблокирован и переключения между потоками не выполняются.

При выполнении функции Scheduler_Unlock во время обработки прерывания
указатель стека должен указывать на стек прерываний, либо прерывания
должны быть запрещены глобально (т.к. если при разблокировании
диспетчера потоков указатель стека указывает на стек потока и
прерывания разрешены, то функция Scheduler_Unlock переходит к выполнению
наиболее приоритетного потока).

Следующие функции гарантированно разблокируют диспетчер потоков:
Sleep, Suspend, Stop, Scheduler_Deblock, Mutex_Get, Mutex_GetWithTimeout,
Signal_Wait, Signal_WaitWithTimeout, Event_Watch, Event_WatchWithTimeout,
Semaphore_Down, Semaphore_DownWithTimeout.  Эти же функции обязательно
разрешают прерывания.



5.1. Блок состояния потока

В блоке состояния потока находятся счетчк сна потока, указатель на
блокирующий ресурс, а также сохраняемые регистры процессора (те из них,
которые не сохраняются в стеке), в том числе регистр-указатель вершины
аппаратного стека.



5.2 Обработка прерываний

Прежде всего нужно отметить, что основным ограничением при разработке silOS
было желание создать инструмент, позволяющий максимально быстро обрабатывать
прерывания.  Как следствие, silOS допускает возможность обработки вложенных
прерываний.  Допустимость вложенных прерываний влечет обязательность
наличия отдельного стека для обработчиков прерываний (иначе место для
вложенных прерываний должно быть выделено в стеке каждого потока, что влечет
неоправданно большой расход памяти).  Кроме того, если хотя бы одна функция
обработки прерывания интенсивно использует стек, то это тоже требует
выделения отдельного стека для обработчиков прерываний.

Предполагалось, что обработчики прерываний будут, в основном, написаны
на ассемблере.  Однако, ничто не мешает писать их на языке C. Для
объявления функции обработки прерывания имеется макрос OS_ISR
(аналогичный макросу ISR библиотеки avr-libc из пакета WinAVR),
определённый в файле os/isr.h.  Этот макрос переключает указатель стека
на стек прерываний и обеспечивает вызов диспетчера потоков после
завершения обработки прерывания.  В ходе выполенения такой функции 
допускается разрешение прерываний.  Если же функция обработки прерывания 
объявлена макросом ISR, то в ходе её выполнения прерывания разрешать нельзя,
т.к. при входе во вложенное прерывание будет считаться, что прервали
функцию потока, а не функцию обработки прерывания, со всеми вытекающими
последствиями.

В файле os/os.inc определены макросы для написание функций обработки 
прерываний на ассемблере: SAVE_REGS, RESTORE_REGS и TO_ISR_STACK.
Там же определён ещё ряд макросов для использования в функциях
на ассемблере, которые повторяют функциональность некоторых
функций, но работают быстрее.

Предполагается, что допускаются вложенные прерывания (для xMega это
скорее даже правило).  Поэтому в начале обработки прерывания
необходимо сохранить регистры макросом SAVE_REGS, выполнить
макрос TO_ISR_STACK, обработать прерывание, выполнить макрос RESTORE_REGS
и завершить обработку прерывания командой reti или ret.

Максимальная вложенность прерываний зависит от размера стека прерываний.

Вложенность прерываний отслеживается по указателю стека: стек
прерываний должен располагаться в младших адресах, а стеки потоков --
в старших адресах, и между этими стеками должен быть "зазор" в 256
байтов минимум.

Пример обработки прерывания по переполнению таймера.

---------------
#include <avr/io.h>
#include "os/os.h"
#include "os/os.inc"
#include "os/tick.inc"		/* макрос системного таймера */
#include "os/timers.inc"	/* макрос прикладных таймеров */

	.text

TIMER1_OVF_vect:	.global TIMER1_OVF_vect
	SAVE_REGS	; сохраняет регистры OS_wReg и SREG

	; действия, которые необходимо выполнить при переполнении
	; таймера 1 максимально быстро (при этом можно использовать
	; регистр OS_wReg)

	TO_ISR_STACK	; переключились на стек прерываний
	sei
	pushw	Z

	; действия, которые необходимо выполнить при переполнении
	; таймера 1

	; тик системного таймера
	; уменьшение счетчиков сна потоков
	OS_TICK		interrupts_enabled, OS_wReg
	; уменьшение счетчиков прикладных таймеров
	OS_TIMERS	interrupts_enabled, OS_wReg

	popw	Z
	RESTORE_REGS
	reti
---------------

Макрос OS_TICK, определенный в файре os/tick.inc, уменьшает
счетчики сна потоков и активизирует те из них, у которых счетчик
сна стал равен нулю.  В качестве обязательных параметров нужно
указать разрешены (interrupts_enabled) или запрещены (interrupts_disabled)
прерывания и рабочий регистр из старшей половины (рабочий регистр
используется только при запрещенных прерываниях, поэтому это может быть
любой регистр).  Если заранее неизвестно разрешены прерывания или
запрещены, то можно указать регистр, в котором будут сохраняться флаги
процессора (для восстановления флага разрешения прерываний) на время
запрещения прерываний.  Регистры ZH и ZL используются макросом OS_TICK
для адресации TSB потоков, поэтому они не могут указываться как рабочие
или для сохранения флагов процессора.

Макрос OS_TIMERS уменьшает счетчики прикладных таймеров до нуля.
Анализ состояния счетчиков выполняется в прикладной программе.



6. Управление потоками (Sleep, Stop, Suspend)

Для управления состоянием текущего потока предназначены следующие функции:
 - Sleep - приостановка текущего потока на указаное время;
 - Stop - завершение текущего потока (с освобождением мьютексов);
 - Suspend - приостановка текущего потока на неопределенное время.

Для управление состоянием прочих потоков предназначены следующие функции:
 - Thread_Activate - активизация указаного потока;
 - Thread_Kill - завершение указаного потока (с освобождением мьютексов);
 - Thread_Prepare - подготовка указаного потока к выполнению определенной
 функции (привязка функции к потоку; или назначение потоку функции).


RegType_t Sleep( SleepTime_t ticks );

Функция Sleep предназначена для приостановки текущего потка на указаное число
тактов системного таймера (точнее, на указаное число раз исполения макроса
OS_TICK).  На восьмиразрядных архитектурах значение ticks (количество тактов,
на которое приостанавливается поток) должно быть до 127 включительно.
Если используются какие-либо средства синхронизации потоков (мьютексы,
семафоры, сигналы и т.п.), то допустимое значение увеличивается до 255. На
архитектурах с большей разрядностью допустимое значение параметра функции
Sleep соответсвенным образом увеличивается (до значения, которое может
быть размещено в одном регистре процессора).

Для удобства определён макрос SleepTime_t_MAX.

Функция Sleep возвращает причину активизации потока: 0 - поток активизирован
по прошествии указаного времени; 240 - поток активизирован функцией
Thread_Activate.  При выполнении функции Sleep разблокируется диспетчер
потоков и разрешаются прерывания.

Функцию Sleep ни в коем случае нельзя вызывать во время обработки прерывания.


void Stop( void );

Функция прекращает работу текущего потока: осовбождает все захваченные
потоком мьютексы, и в бесконечном цикле вызывает функцию Suspend.
Управление из функции Stop более никуда не передается.  При выполнении
функции Stop разблокируется диспетчер потоков и разрешаются прерывания.

Функцию Stop ни в коем случае нельзя вызывать во время обработки прерывания.


void Suspend( void );

Функция Suspend приостанавливает текущий поток до его явной активизации
функцией Thread_Activate (например, при обработки какого-либо прерывания).
При выполнении функции Suspend разблокируется диспетчер потоков и
разрешаются прерывания.

Функцию Suspend ни в коем случае нельзя вызывать во время обработки прерывания.


TSBindex_t Thread_Activate( TSBindex_t idx );

Функция активизирует поток с номером idx.  После выполнения данной функции
указаный поток готов к выполнению, и, если диспетчер потоков разблокирован и
данный поток имеет более высокий приоритет (меньший номер) чем текущий
поток, то он немедленно (или сразу после окончания обработки прерывания)
начинает выполняться.


TSBindex_t Thread_Kill( TSBindex_t idx );

Функция прекращает выполнение указаного потока.  Все мьютексы, которыми
владел поток, освобождаются.  В случае активизации в дальнейшем потока idx
(ошибочной или случайной) в нем будет выполнена функция Stop.  Если
завершается работа текущего потока (например, при обработке прерывания), то
разблокируется диспетчер потоков; если при этом не выполняется процедура
обработки прерывания, то прерывания разрешаются.

Если функция Thread_Kill не вызывается во время обработки прерываний,
то можно определить макрос NO_KILL_IN_ISR.  Это несколько уменьшит
размер ОС и время выполнения некоторых функций.


TSBindex_t Thread_Prepare( TSBindex_t idx, THREAD_PTR func, intptr_t data );

Фнукция Thread_Prepare назначает потоку с номером idx функцию func
и активизирует его.  Если после назначения потку функции необходимо
блокировать поток, то номер потока idx должен быть отрицательным.

Функция Thread_Prepare освобождает все мьютексы, которыми владел
подготавливаемый поток.  Функция возвращает номер подготовленного
потока (всегда больше нуля).

Перед вызовом функции Thread_Prepare во время обработки прерывания
необходимо изменить стек на стек прерываний (в ассемблерном коде
макросом TO_ISR_STACK, в коде на C объявлением фукнции обрабоки
прерывания макросом OS_ISR).

При назначении функции потоку имеется возможность передать в неё
некоторый параметр data.  Способ реализации передачи параметра зависит от того,
возможен ли вызов функции Thread_Prepare во время обработки прерываний:
если допускается вызов фунции Thread_Prepare при обработке прерываний,
то параметр в функцию потока можно передавать только через стек;
если же функцию Thread_Prepare не предполагается вызывать во время
обработки прерываний (и поэтому определём макрос NO_PREPARE_IN_ISR),
то параметр можно передавать в регистре.  В соответствии с этим определение
типа THREAD_PTR может быть одним из следующих:

typedef void (*THREAD_PTR)(intptr_t);
или
typedef void (*THREAD_PTR)(intptr_t, ...);

Для универсальности введены следующие макросы: DECLARE_THREAD(),
THREAD() и NO_PREPARE_IN_ISR.  Макрос NO_PREPARE_IN_ISR должен быть не равен
нулю, если не предполагаются вызовы функции Thread_Prepare при обработке
прерываний.  Макрос DECLARE_THREAD(name, type data) объявляет функцию
потока с именем name и параметром data типа type.  Макрос THREAD(name,
type data) формирует заголовок функции name с параметром data типа type.
Для приведения адреса функции потока к типу ожидаемому функцией
Thread_Prepare, используется тип THREAD_PTR.

Если фунция Thread_Prepare назначает функцию текущему потоку (например, при
обработки прерывания), то диспетчер потоков обязательно разблокируется; если
при этом не выполняется процедура обработки прерывания, то прерывания
разрешаются.

Пример использования этих макросов, функции Thread_Prepare и типа
THREAD_PTR:

---------------
DECLARE_THREAD( thread2, int data );

THREAD( thread1, void* ptr )
{
	...
	/* назначаем потоку 2 фукнцию thread2 и поток блокируем */
	Thread_Prepare( -2, thread2, (int)ptr );
	...
	/* завершаем текущий поток */
	Stop();
} // thread1

THREAD( thread2, int data )
{
	...
	do {
	...
	} while (1);
} // thread2

int main( void )
{
	...
	/* назначае потоку 1 функцию thread1 и сразу его запускаем */
	Thread_Prepare( 1, (THREAD_PTR)thread1, (void*)5 );
	...
	/* активизируем поток 2 */
	Thread_Activate( 2 );
	...
} // main
---------------



7. Синхронизация потоков

Для синхронизации потоков используются: мьютексы, семафоры, сигналы,
события.  Количество мьютексов, семафоров, сигналов и событий указывается в
момент компиляции и во время работы программы меняться не может.  Общее
количество указаных средств синхронизации не может превышать 254 (на
восьмиразрядной архитектуре).

При использовании средств синхронизации нужно помнить о возможных ситуациях
"гонок": состояние средства синхронизации может измениться между анализом
его состояния функцией операционной системы и возвратом к выполнению
программы (если разрешены прерывания).

При использовании любого количества средств синхронизации каждый блок
состояния потока увеличивается на одну ячейку памяти (при байтовой
организации памяти это будет один байт).  (Правильнее было бы сказать, что
при отказе от всех средств синхронизации можно съэкономить по одному байту в
каждом блоке состояния потока, т.к. обычно какие-либо средства синхронизации
используются.)



7.1. Мьютексы

Мьютексы используются для организации монопольного доступа к разделяемым
ресурсам.  Для каждого из разделяемых ресурсов выделяется мьютекс.  Перед
использованием ресурса, поток должен пытаться захватить соответствующий
мьютекс.  Если мьютекс занят, то поток будет ожидает его освобождения.
После того, как мьютекс осовбодится, поток захватит его и только после
этого он может начинать работать с разделяемым ресурсом.  После окончания
работы с ресурсом поток должен освободить мьютекс.

Номера мьютексов начинаются с 1.  Общее количество мьютексов задается
макросом TotalMutexes при компиляции программы.  Для каждого мьютекса
дополнительно отводится одна ячейка памяти (при байтовой организации памяти
это будет один байт).

Часть мьютексов с номерами от 1 до NumCMutexes являются счетными.  С каждым
таким мьютексом связан счетчик захватов мьютекса, который увеличивается при
каждом успешном или повторном захвате мьютекса функциями Mutex_...Get... и
уменьшается при каждой попытке его освободить функцией Mutex_Release.
Действительное освобождение мьютекса происходит при достижении счетчиком
значения 0.  Прочие мьютексы являются бинарными и освобождаются при первом
же обращении к функции Mutex_Release с соответствующим номером мьютекса в
качестве парамета.  Для каждого счетного мьютекса дополнительно выделяется
ещё одна ячейка памяти.

При старте программы все мьютексы считаются свободными.

Для работы с мьютексами используются следующие функции:

Mutex_Get - захват мьютекса; если мьютекс занят, то поток блокируется;
Mutex_TryGet - попытка захвата мьютекса без блокировки потока;
Mutex_GetWithTimeout - захват мьютекса с таймаутом;
Mutex_Release - освобождение мьютекса;
Mutex_Owner - определение потока-владельца мьютекса.


RegType_t Mutex_Get( Mutex_t mut );

Захватывает мьютекс с номером mut.  Если мьютекс занят, то поток
неопределённо долго ожидает его освобождения.  Функция в любом случае
разблокирует диспетчер потоков и разрешает прерывания.

Для счетного мьютекса ведёт учет числа успешных захватов мьютекса.

Возвращаемые значения:
1 - мьютекс захвачен текущим потоком; с разделяемым ресурсом можно работать;
3 - повторный захват мьютекса; поток уже владел мьтексом в момет вызова
    функции Mutex_Get; с разделяемым ресурсом можно работать;
4 - взаимная блокировка (deadlock); мьютекс захвачен потоком, который
    ожидает освобождения мьютекса, захваченного текущим потоком
    (непосредственно, или через длинную цепочку мьютексов и потоков);
    с разделяемым ресурсом работать нельзя;
240 - поток активизирован с помощью функции Thread_Activate;
    с разделяемым ресурсом работать нельзя.

Функцию Mutex_Get ни в коем случае нельзя вызывать во время обработки
прерывания.


RegType_t Mutex_TryGet( Mutex_t mut );

Захватывает мьютекс с номером mut, если он свободен.  Если мьютекс захвачен
другим потоком, то ничего не делает.

Для счетного мьютекса ведёт учет числа успешных захватов мьютекса.

Возвращаемые значения:
0 - мьютекс захвачен другим потоком; с разделяемым ресурсом работать нельзя;
1 - мьютекс захвачен текущим потоком; с разделяемым ресурсом можно работать;
3 - повторный захват мьютекса; поток уже владел мьтексом в момет вызова
    функции Mutex_TryGet; с разделяемым ресурсом можно работать.

Функцию Mutex_TryGet нельзя использовать во время обработки прерывания,
т.к. прерыванием может быть прерван тот поток, который владеет мьютексом,
и в этом случае произойдёт ошибочный повторный захват мьютекса
(в прерывании нужно использовать функцию Mutex_Owner).


RegType_t Mutex_GetWithTimeout( Mutex_t mut, SleepTime_t ticks );

Захватывает мьютекс с номером mut.  Если мьютекс занят, то ожидает его
освобождения не более ticks тактов системного таймера.  Если
параметр ticks равен 0, то ожидает до освобождения мьютекса (аналогично
функции Mutex_Get). Функция в любом случае разблокирует диспетчер
потоков и разрешает прерывания.

Для счетного мьютекса ведёт учет числа успешных захватов мьютекса.

Возвращаемые значения:
0 - поток активизирован по таймауту, мьютекс захвачен другим потоком; с
    разделяемым ресурсом работать нельзя;
1 - мьютекс захвачен текущим потоком; с разделяемым ресурсом можно работать;
3 - повторный захват мьютекса; поток уже владел мьтексом в момет вызова
    функции Mutex_GetWithTimeout; с разделяемым ресурсом можно работать;
4 - взаимная блокировка (deadlock); мьютекс захвачен потоком, который
    ожидает освобождения мьютекса, захваченного текущим потоком
    (непосредственно, или через длинную цепочку мьютексов и потоков);
    с разделяемым ресурсом работать нельзя;
240 - поток активизирован с помощью функции Thread_Activate;
    с разделяемым ресурсом работать нельзя.

Функцию Mutex_GetWithTimeout ни в коем случае нельзя вызывать во время
обработки прерывания.


void Mutex_Release( Mutex_t mut );

Освобождает мьютекс с номером mut.  В текущей реализации мьютекс может
освободить любой поток (не обязательно тот, который его захватывал).
Необходимость блокировки освобождения мьютекса не тем потоком, который его
захватывал, вызывает сомнения, но реализовать это можно довольно просто
(только нужно учитывать, что в этом случае пропадёт возможность
освобождать мьютексы в прерываниях).

Освобождение счетного мьютекса происходит только после достижения нуля
соответствующим счетчиком числа захватов мьютекса (функции Mutex_...Get...
увеличивают данный счетчик, а функция Mutex_Release -- уменьшает).

Если функция Mutex_Release не вызывается во время обработки прерываний,
то можно определить макрос NO_RELEASE_IN_ISR.  Это несколько уменьшит
размер ОС и время выполнения некоторых функций.


TSBindex_t Mutex_Owner( Mutex_t mut );

Возвращает номер потока, владеющего указаным мьютексом.  Возвращает ноль,
если мьютекс свободен (если прерывания разрешены и диспетчер потоков
разблокирован, то мьютекс может оказаться захваченым каким либо другим
потоком уже после возврата из функции Mutex_Owner).



7.2. Семафоры

Семафоры используются для ограничения количества потоков одновременно
работающих с ресурсом, или ограничивают количество некоторого ресурса
(например, количество свободных элементов в очереди может задаваться
семафором).  Семафор реализуется переменной-счетчиком.  Семафор может быть в
одном из двух состояниях: закрыт (соответствует значению ноль в
переменной-счетчике) и открыт (соответствует ненулевому значению в
переменной-счетчике).  При закрытии семафора переменная счетчик уменьшается
(до нуля), при открытии -- увеличивается.  Если семафор закрыт, то при
попытке его закрыть поток приостанавливается.  При открытии семафора, если
есть потоки, ожидающие его открытия, активизируется наиболее приоритетный из
них (семафор при этом остаётся закрытым).

Пара полезных метафор, связаных с семафорами.  Первая метафора: значение
переменной-счетчика семафора можно рассматривать как количество свободных
путей за ним.  Другая метафора: значение переменной-счетчика семафора можно
рассматривать как высоту поднятия шлагбаума, при этом закрытому шлагбауму
соответствует нулевое значение переменной.

Номера семафоров начинаются с 1.  Общее количество семафоров задается
макросом NumSemaphores при компиляции программы.  Для каждого семафора
дополнительно отводится одна ячейка памяти (при байтовой организации памяти
это будет один байт).

При старте программы все семафоры, кроме инициализированных макросом
INIT_SEMAPHORE, закрыты.

Для работы с семафорами используются следующие функции и макросы:

Semaphore_Up - открытие семафора (поднятие шлагбаума);
Semaphore_Down - закрытие семафора (опускание шлагбаума);
Semaphore_TryDown - попытка закрытия семафора;
Semaphore_DownWithTimeout - закрытие семафора с таймаутом;
Semaphore_State - запрос состояния семафора;
INIT_SEMAPHORE - инициализация семафора;
SET_SEMAPHORE - принудительная установка переменной-счетчика семафора.


SemaphoreCounter_t Semaphore_Up( Semaphore_t sem );

Открывает семафор (поднимает шлагбаум).  Увеличивает значение
соответствующей семафору sem переменной-счетчика.  Контроля на переполнение
переменной не осуществляется.  Возвращает новое значение
переменной-счетчика (может вернуть ноль, если были потоки, которые ожидали
открытия данного семафора).  Активизирует наиболее приоритетный из потоков,
ожидавших открытия данного семафора (если такие потоки были).


RegType_t Semaphore_Down( Semaphore_t sem );

Закрывает семафор (опускает шлагбаум).  Уменьшает значение соответствующей
семаформу sem переменной-счетчика на единицу, если там был не ноль.  Если в
переменной был ноль (семафор закрыт), то поток приостанавливается до
открытия данного семафора.  Функция в любом случае разблокирует диспетчер 
потоков и разрешает прерывания.

Возвращаемые значения:
1 - семафор успешно закрыт;
240 - в момент вызова функции Semaphore_Down семафор был закрыт; поток был
    активизирован функцией Thread_Activate (т.е. открытия семафора не
    дождались).

Функцию Semaphore_Down ни в коем случае нельзя вызывать во время обработки
прерывания.


RegType_t Semaphore_TryDown( Semaphore_t sem );

Закрывает семафор (уменьшает значение соответствующей семаформу sem
переменной-счетчика на единицу), если он открыт.  Если семафор уже закрыт,
то ничего не делает.

Возвращаемые значения:
0 - семафор уже закрыт, нечего не было сделано;
1 - семафор был открыт, функция уменьшила значение счетчика семафора.


RegType_t Semaphore_DownWithTimeout( Semaphore_t sem, SleepTime_t ticks );

Закрывает семафор (опускает шлагбаум).  Уменьшает значение соответствующей
семаформу sem переменной-счетчика на единицу, если там был не ноль.  Если в
переменной был ноль (семафор закрыт), то поток приостанавливается на
указаное количество тактов системного таймера (ticks).  Если
параметр ticks равен 0, то поток приостанавливается до открытия семафора
(аналогично функции Semaphore_Down).  Функция в любом случае разблокирует
диспетчер потоков и разрешает прерывания.

Возвращаемые значения:
0 - поток активизирован по таймауту; семафор был закрыт и функция
    Semaphore_DownWithTimeout его не закрывала;
1 - семафор успешно закрыт;
240 - в момент вызова функции Semaphore_DownWithTimeout семафор был закрыт
    и функция Semaphore_DownWithTimeout его не закрывала; поток был
    активизирован функцией Thread_Activate (т.е. открытия семафора
    не дождались).

Функцию Semaphore_DownWithTimeout ни в коем случае нельзя вызывать во время
обработки прерывания.


SemaphoreCounter_t Semaphore_State( Semaphore_t sem );

Возвращает значение переменной-счетчика, соответствующей семафору sem.


INIT_SEMAPHORE( sem, val );

Инициализирует переменную-счетчик семафора sem значением val (семафор
становится открытым, если значение val не ноль).  Инициализация выполняется
до начала выполнения функции main.


SET_SEMAPHORE( sem, val );

Принудительно устанавливает переменную-счетчик семафора sem в значение val;
при этом никакие потоки не активизируются.  

Макрос INIT_SEMAPHORE используется вне функций, аналогично объявлению
глобальной переменной, а SET_SEMAPHORE -- это действие, которое изменяет
значение переменной-счетчика и может выполняеться только в контексте некоторой
функции.


Пример повторно входимой (reentrant) реализации очереди с использованием
семафоров (см.[2], стр.138).

---------------
#include "os/os.h"
#define QueLen	10	/* кол-во элементов в очереди */

int buf[QueLen];	/* буфер под очередь */
int head, tail;		/* индексы первого и последнего элементов очереди */

#define QUE_EMPTY_SEMAPHORE 1
#define QUE_FILLED_SEMAPHORE 2

INIT_SEMAPHORE( QUE_EMPTY_SEMAPHORE, QueLen );

void Put( int val )
{
	Semaphore_Down( QUE_EMPTY_SEMAPHORE );
	cli(); // доступ к переменной tail не атомарный
	buf[tail++] = val;
	if ( tail == QueLen ) tail = 0;
	sei();
	Semaphore_Up( QUE_FILLED_SEMAPHORE );
} // Put

int Get( void )
{
	int val;
	Semaphore_Down( QUE_FILLED_SEMAPHORE );
	cli(); // доступ к переменной head не атомарный
	val = buf[head++];
	if ( head == QueLen ) head = 0;
	sei();
	Semaphore_Up( QUE_EMPTY_SEMAPHORE );
	return val;
} // Get
---------------



7.3. Сигналы

С помощью сигналов потоки (или прерывания) сообщают другим потокам (или
прерываниям) о выполнении некоторого условия (или состояния): например, о
состоянии кнопки или о наличии байта в регистре данных шины SPI.  Сигнал
имеет два состояния (сброшен и установлен) и реализуется битовой переменной.
При установке сигнала все потоки, которые ожидали данный сигнал, переводятся
в состояние готовности к выполнению.  После установки сигнала он остается
активным в течении некоторого времени, до его явного сброса.  Поток
переводится в состояние ожидания сигнала только в том случае, если в момент
обращения к сигналу тот будет сброшен.

Номера сигналов начинаются с 1.  Общее количество сигналов задается макросом
NumSignals при компиляции программы.  Для каждых восьми сигналов
дополнительно отводится по одному байту оперативной памяти.

Для работы с сигналами используются следующие функции:

Signal_Set - устанавливает сигнал;
Signal_Reset - сбрасывает сигнал;
Signal_IsSet - возвращает состояние сигнала;
Signal_Wait - блокирует работу потока до установки сигнала;
Signal_WaitWithTimeout - блокирует работу потока до установки сигнала с
таймаутом.


RegType_t Signal_Set( Signal_t sig );

Устанавливает сигнал sig.  Активизирует все потоки, которые ожидали
установки данного сигнала.  Возвращает не 0, если был хотя бы один поток,
который ожидал данного сигнала.  Если данный сигнал никто не ожидал, то
возвращает 0.


void Signal_Reset( Signal_t sig );

Сбрасывает сигнал sig.


RegType_t Signal_IsSet( Signal_t sig );

Возвращает не 0, если сигнал sig установлен.  Если сигнал sig сброшен, то
возвращает 0.


RegType_t Signal_Wait( Signal_t sig );

Если сигнал sig установлен, то ничего не делает.  Если сигнал sig сброшен,
то приостанавливает текущий поток до установки сигнала sig.  Функция в любом
случае разблокирует диспетчер потоков и разрешает прерывания.

Возвращаемые значения:
1 - сигнал установлен;
240 - сигнал не установлен, поток активизирован функцией Thread_Activate.

Функцию Signal_Wait ни в коем случае нельзя вызывать во время обработки
прерывания.


RegType_t Signal_WaitWithTimeout( Signal_t sig, SleepTime_t ticks );

Если сигнал sig установлен, то ничего не делает.  Если сигнал sig сброшен,
то блокирует текущий поток на указаное количество (ticks) тактов системного
таймера или до установки сигнала sig.  Если параметр ticks равен 0, то
поток блокируется до установки сигнала (аналогично функции Signal_Wait).
Функция в любом случае разблокирует диспетчер потоков и разрешает прерывания.

Возвращаемые значения:
0 - поток активизирован по таймауту; сигнал не установлен;
1 - сигнал установлен;
240 - сигнал не установлен, поток активизирован функцией Thread_Activate.

Функцию Signal_WaitWithTimeout ни в коем случае нельзя вызывать во время
обработки прерывания.



7.4. События

События аналогичны сигналам, за тем исключением, что у событий нет
состояния (и нет длительности).  События полезны в тех случаях, когда
синхронизация потоков выполняется периодическим событием (например,
окончание предыдущего и начало очередного часа суток; такое событие
наступает каждый час и не имеет длительности).

Для реализации событий используются те же области памяти, которые
используются для реализации прочих средств синхронизации; т.е. использование
событий не влечет увеличения требований к оперативной памяти (если кроме
событий используется ещё любое другое средство синхронизации потоков).
Использование для синхронизации потоков исключительно событий влечет уже
упомянутое увеличение размера блока состояния потока на одну ячейку памяти.

Номера событий начинаются с 1.  Общее количество событий задается макросом
NumEvents при компиляции программы.

Для работы с событиями используются следующие функции:
Event_Occur - "событие произошло"; сообщение о том, что событие случилось;
Event_Watch - ожидание события;
Event_WatchWithTimeout - ожидание события с таймаутом.


RegType_t Event_Occur( Event_t evnt );

Функция Event_Occur активизирует все потоки, которые ожидали наступления
события evnt.


RegType_t Event_Watch( Event_t evnt );

Выполнение функции Event_Watch вызывает блокировку текущего потока до
наступления события evnt.  При этом разблокируется диспетчер потоков и
разрешаются прерывания.

Возвращаемые значения:
1 - поток дождался наступления события;
240 - событие не наступило, поток активизирован функицей Thread_Activate.

Функцию Event_Watch ни в коем случае нельзя вызывать во время обработки
прерывания.


RegType_t Event_WatchWithTimeout( Event_t evnt, SleepTime_t ticks );

Выполнение функции Event_WatchWithTimeout блокирует текущий поток на
указаное количество (ticks) тактов системного таймера или до наступления
события evnt.  При этом разблокируется диспетчер потоков и разрешаются
прерывания.  Если параметр ticks равен 0, то поток блокируется до
наступления события (аналогично функции Event_Watch).

Возвращаемые значения:
0 - поток активизирован по таймауту, событие не наступило;
1 - поток дождался наступления события;
240 - событие не наступило, поток активизирован функицей Thread_Activate.

Функцию Event_WatchWithTimeout ни в коем случае нельзя вызывать во время
обработки прерывания.



8. Макросы, стек, регистры

8.1 Макросы

DECLARE_THREAD( thread_name, thread_parameter )
THREAD( thread_name, thread_parameter )

Первый макрос объявляет, а второй определяет функцию потока с именем
thread_name и параметром thread_parameter.  Параметр thread_parameter
может быть любого типа, размер которого не 0 и не больше размера типа
intptr_t.  Для приведения типа фикции потока к тому, который ожидает
функця Thread_Activate, определён тип THREAD_PTR.

Типичное использование данных макросов следующее:

DECLARE_THREAD( some_thread, SleepTime ms );

int main( void )
{
	...
	Prepare_Thread( -SOME_THREAD_PRIORITY, (THREAD_PTR) some_thread, 5 );
	Activate_Thread( SOME_THREAD_PRIORITY );
	...
} // main

THREAD( some_thread, SleepTime ms )
{
	...
	do {
		...
		Sleep( ms * _1ms );
		...
	} while ( 1 );
} // some_thread







Литература

[1] D.M. Auslander, J.R. Ridgely, J.D. Ringgenberg: Design and
Implementation of Real Time Software for Control of Mechanical Systems

[2] Эндрюс Г.Р. "Основы многопоточного, параллельного и распределенного
программирования.": Пер.с англ. - М.:Издательский дом "Вильямс", 2003 - 512с

[3] Сорокин С. "Системы реального времени": Журнал "СТА" 2/97
